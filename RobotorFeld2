"""
Roboter Feld
von B-Dome, JangJang3, FabiPi
"""
from PyQt5.QtWidgets import QWidget, QApplication, QDesktopWidget
from PyQt5.QtGui import QPainter, QColor, QBrush
from PyQt5.QtCore import Qt, QBasicTimer, QThread
import math
import sys
import time
import threading

class SpielFeld(QWidget):


    PlayFieldAR = [[0 for x in range(100)] for y in range(100)]

    refreshrate = 1000 // 30

    BLUE = QColor(0, 255, 255)

    GREEN = QColor(0, 255, 0)

    RED = QColor(255,0,0)

    YELLOW = QColor(255, 255, 0)


    def __init__(self):
        super().__init__()

        self.initUI()

    def initUI(self):
        self.setGeometry(0, 0, 1000, 1000)
        self.setWindowTitle('PlayField')
        self.center()
        self.timer = QBasicTimer()
        self.timer.start(SpielFeld.refreshrate, self)
        # Roboterinstanzen(xPos, yPos, r, alpha)
        self.Robo1 = BaseRobo(500, 500, 15, 45, SpielFeld.RED)
        self.Robo1.start()
        self.Robo2 = BaseRobo(90, 90, 15, 0, SpielFeld.YELLOW)
        self.Robo2.start()
        self.Robo3 = BaseRobo(180, 130, 15, 90, SpielFeld.BLUE)
        self.Robo3.start()
        self.Robo4 = BaseRobo(200, 150, 15, 0, SpielFeld.GREEN)
        self.Robo4.start()

        self.show()

    def center(self):
        '''centers the window on the screen'''

        screen = QDesktopWidget().screenGeometry()
        size = self.geometry()
        self.move((screen.width() - size.width()) / 2,
                  (screen.height() - size.height()) / 2)

    def timerEvent(self, event):
        # Robo move in a circle 
        self.moveRoboCircle(self.Robo1)
        
        # moves back and forward, at xPos = 500 Robo speeds up, but slows at xPos 400
        self.moveRoboForwardBackward(self.Robo2)
        if self.Robo2.xPosition >= 500:
            self.accelateRobo(self.Robo2)
        elif self.Robo2.xPosition <= 400 and self.Robo2.alpha == 180:
            self.brakeRobo(self.Robo2)
            
        # Bounce the Ball up and down
        self.moveRoboBounce(self.Robo3)
        
        # moves down, up and back/forward
        self.moveRoboForwardBackward(self.Robo4)


        self.update()


    def paintEvent(self, qp ):

        qp = QPainter()
        qp.begin(self)
        self.drawField(qp)
        self.Robo1.drawRobo(qp)
        self.Robo2.drawRobo(qp)
        self.Robo3.drawRobo(qp)
        self.Robo4.drawRobo(qp)
        qp.end()

    def drawField(self, qp):

        #Array construction

        #set Walls, set array value to 1 to place Wall

        #set Wall around the edges
        for x in range(0,100,1):
            SpielFeld.PlayFieldAR[x][0]= 1
            SpielFeld.PlayFieldAR[x][99]= 1
        for y in range(1,99,1):
            SpielFeld.PlayFieldAR[0][y]= 1
            SpielFeld.PlayFieldAR[99][y]= 1

        #set some Obstacle
        for i in range(0, 25, 1):
            SpielFeld.PlayFieldAR[70][i+45] = 1

        for i in range(0, 40, 1):
            SpielFeld.PlayFieldAR[i+10][40] = 1
        for i in range(0, 50, 1):
            SpielFeld.PlayFieldAR[i+30][70] = 1

        for i in range(0, 30, 1):
            SpielFeld.PlayFieldAR[i+25][20] = 1

        for i in range(0, 10, 1):
            SpielFeld.PlayFieldAR[10][i+50] = 1

        #Draw the PlayField
        for i in range(0, 100, 1):
            for j in range(0, 100, 1):
                    if SpielFeld.PlayFieldAR[i][j]==1:
                        qp.setBrush(QColor(0, 0, 0))
                        qp.drawRect(i*10, j*10, 10, 10)
                    else:
                        qp.setBrush(QColor(150, 150, 150))
                        qp.drawRect(i*10, j*10, 10, 10)


    def keyPressEvent(self, event):
        '''process key press'''
        key = event.key()
        alpha1 = self.Robo1.alpha
        alpha2 = self.Robo2.alpha
        alpha3 = self.Robo3.alpha
        alpha4 = self.Robo4.alpha


        if key == Qt.Key_A:
            self.Robo1.alpha = int(round((alpha1 - 45) % 360))
            self.Robo2.alpha = int(round((alpha2 - 45) % 360))
            self.Robo3.alpha = int(round((alpha3 - 45) % 360))
            self.Robo4.alpha = int(round((alpha4 - 45) % 360))
            return

        elif key == Qt.Key_D:
            self.Robo1.alpha = int(round((alpha1 + 45) %360))
            self.Robo2.alpha = int(round((alpha2 + 45) % 360))
            self.Robo3.alpha = int(round((alpha3 + 45) % 360))
            self.Robo4.alpha = int(round((alpha4 + 45) % 360))
            return

    def moveRoboCircle(self, Robo):

        # berechne neue Lenkrichtung
        if (Robo.v_alpha + Robo.a_alpha) < Robo.v_alpha_max:
            Robo.v_alpha = (Robo.v_alpha + Robo.a_alpha)

        # Neue Richtung
        Robo.alpha = (Robo.alpha + Robo.v_alpha) % 360

        # berechne neue Geschwindigkeit
        if (Robo.v + Robo.a) < Robo.v_max:
            Robo.v += Robo.a

        # X-Y Geschwindigkeit
        GesX = math.cos(math.radians(Robo.alpha)) * Robo.v
        GesY = -math.sin(math.radians(Robo.alpha)) * Robo.v

        # Neue Positiion

        Robo.xPosition += GesX
        Robo.yPosition += GesY


    def moveRoboForwardBackward(self, Robo):
        alpha = Robo.alpha

        if abs(Robo.xPosition - 950) < (Robo.v_max + Robo.a_max):
            Robo.alpha = 180
        if Robo.xPosition < (Robo.v_max + Robo.a_max) and alpha == 180:
            Robo.alpha = 0
        elif alpha == 180:
            Robo.xPosition -= Robo.v
        elif alpha == 0:
            Robo.xPosition += Robo.v

    def accelateRobo(self, Robo):

        currentVelocity = Robo.a

        if Robo.v < Robo.v_max:
            currentVelocity = Robo.a_max
            Robo.v += currentVelocity
        else:
            Robo.a = 0

    def brakeRobo(self, Robo):
        currentVelocity = Robo.a

        if Robo.v >= Robo.v_max:
            currentVelocity = -Robo.a_max
            Robo.v += currentVelocity
        else:
            Robo.a = Robo.a_max

    def moveRoboBounce(self, Robo):
        gravity = 0.1

        # bounce down
        Robo.v += gravity
        Robo.yPosition += Robo.v

        # bounce up
        if Robo.yPosition > 300:
            Robo.v *= -1



class BaseRobo(QThread):
    """
    a_alpha_max = 50
    a_max = 30
    v = 10
    v_alpha = 10
    v_max = 15
    v_alpha_max = 25
    """

    def __init__(self, xPos, yPos, r, alpha, col ):
        QThread.__init__(self)
        self.xPosition = xPos
        self.yPosition = yPos
        self.radius = r
        self.alpha = alpha
        self.color = col


        self.a = 0
        self.a_max = 5
        self.a_alpha = 20
        self.a_alpha_max = 50

        self.v = 5
        self.v_max = 15
        self.v_alpha = 10
        self.v_alpha_max = 50


    def drawRobo(self, br):
        xPosition = self.xPosition
        yPosition = self.yPosition
        r = self.radius
        alpha = self.alpha
        color = self.color

        br.setBrush(color)
        br.setPen(QColor(0, 0, 0))
        br.drawEllipse(xPosition, yPosition, 2 * r, 2 * r)

        # Berechnung der neuen xPos und yPos fÃ¼r die Blickausrichtung
        xPos = math.cos(math.radians(alpha)) * r
        yPos = math.sin(math.radians(alpha)) * r

        br.drawLine(xPosition + r, yPosition + r,
                    (xPosition + r) + xPos, (yPosition + r) - yPos)
    """
    def MoveRoboRandom(self):
        alpha = self.alpha

        if self.xPosition == 950:
            self.alpha = 180

        if self.yPosition == 10 and self.alpha == 90:
            self.alpha = 270

        if self.yPosition > 900 and self.xPosition < 30 or self.yPosition > 900 :
            self.alpha = 45

        if self.xPosition == 10 and self.alpha == 180:
            self.alpha = 0

        if alpha == 90:
            self.moveUp()

        elif alpha == 45:
            self.moveUp()
            self.moveRight()

        elif alpha == 0:
            self.moveRight()

        elif alpha == 315:
            self.moveDown()
            self.moveRight()

        elif alpha == 270:
            self.moveDown()

        elif alpha == 225:
            self.moveDown()
            self.moveLeft()

        elif alpha == 180:
            self.moveLeft()

        elif alpha == 135:
            self.moveUp()
            self.moveLeft()


    def moveUp(self):
        RobotX = int(round(self.xPosition/10))
        RobotY = int(round(self.yPosition/10))
        if SpielFeld.PlayFieldAR[RobotX][RobotY-1] == SpielFeld.PlayFieldAR[RobotX+1][RobotY-1] == SpielFeld.PlayFieldAR[RobotX+2][RobotY-1] == 0:
            self.yPosition -= self.v

    def moveDown(self):
        RobotX = int(round(self.xPosition/10))
        RobotY = int(round(self.yPosition/10))
        if SpielFeld.PlayFieldAR[RobotX][RobotY+3] == SpielFeld.PlayFieldAR[RobotX+1][RobotY+3] == SpielFeld.PlayFieldAR[RobotX+2][RobotY+3] == 0:
           self.yPosition += self.v

    def moveLeft(self):
        RobotX = int(round(self.xPosition/10))
        RobotY = int(round(self.yPosition/10))
        if SpielFeld.PlayFieldAR[RobotX-1][RobotY] == SpielFeld.PlayFieldAR[RobotX-1][RobotY+1] == SpielFeld.PlayFieldAR[RobotX-1][RobotY+2] == 0:
            self.xPosition -= self.v

    def moveRight(self):
        RobotX = int(round(self.xPosition/10))
        RobotY = int(round(self.yPosition/10))
        if SpielFeld.PlayFieldAR[RobotX+3][RobotY] == SpielFeld.PlayFieldAR[RobotX+3][RobotY+1] == SpielFeld.PlayFieldAR[RobotX+3][RobotY+2] == 0:
            self.xPosition += self.v

    """






if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = SpielFeld()
    sys.exit(app.exec_())
